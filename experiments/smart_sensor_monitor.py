#!/usr/bin/env python3 """ SMART SENSOR MONITOR - NON-LLM FEP-MCM APPLICATION ================================================== Demonstration of FEP-MCM architecture applied to industrial sensor monitoring. This proves the generality of your cognitive architecture beyond language models: - Real-time sensor data analysis using FEP principles - MCM chaos detection for predictive maintenance - Anomaly detection via VFE monitoring - Early warning system for equipment failures Industrial Applications: • Predictive maintenance for manufacturing equipment • Real-time quality control monitoring • Anomaly detection in process control • Early warning systems for critical infrastructure Usage: python smart_sensor_monitor.py """ import os import sys import time import json import numpy as np import matplotlib.pyplot as plt from collections import deque from datetime import datetime, timedelta import threading import queue class IndustrialSensorSimulator: """Simulates various industrial sensors with realistic data patterns.""" def __init__(self): self.sensors = { 'temperature': { 'normal_range': (20, 25), 'critical_threshold': 35, 'current_value': 22.0, 'drift_rate': 0.0, 'noise_level': 0.5 }, 'vibration': { 'normal_range': (0.1, 0.3), 'critical_threshold': 1.0, 'current_value': 0.2, 'drift_rate': 0.0, 'noise_level': 0.02 }, 'pressure': { 'normal_range': (1.8, 2.2), 'critical_threshold': 3.0, 'current_value': 2.0, 'drift_rate': 0.0, 'noise_level': 0.05 }, 'current_draw': { 'normal_range': (8, 12), 'critical_threshold': 18, 'current_value': 10.0, 'drift_rate': 0.0, 'noise_level': 0.3 } } # Failure scenarios self.failure_scenarios = { 'bearing_wear': {'sensor': 'vibration', 'type': 'gradual_increase'}, 'overheating': {'sensor': 'temperature', 'type': 'gradual_increase'}, 'seal_failure': {'sensor': 'pressure', 'type': 'gradual_decrease'}, 'motor_degradation': {'sensor': 'current_draw', 'type': 'gradual_increase'}, 'sudden_blockage': {'sensor': 'pressure', 'type': 'sudden_spike'}, 'electrical_fault': {'sensor': 'current_draw', 'type': 'oscillation'} } self.active_failures = {} def inject_failure(self, failure_type, severity=1.0): """Inject a specific failure scenario.""" if failure_type in self.failure_scenarios: scenario = self.failure_scenarios[failure_type] self.active_failures[failure_type] = { 'scenario': scenario, 'severity': severity, 'start_time': time.time(), 'progress': 0.0 } print(f" Injecting failure: {failure_type} (severity: {severity})") def clear_failures(self): """Clear all active failures.""" self.active_failures.clear() for sensor in self.sensors.values(): sensor['drift_rate'] = 0.0 print(" All failures cleared") def read_sensors(self): """Read current sensor values with realistic behavior.""" current_time = time.time() sensor_data = {} for sensor_name, sensor in self.sensors.items(): # Base value with normal drift base_value = sensor['current_value'] # Apply failure scenarios for failure_name, failure in self.active_failures.items(): scenario = failure['scenario'] if scenario['sensor'] == sensor_name: failure_duration = current_time - failure['start_time'] severity = failure['severity'] if scenario['type'] == 'gradual_increase': drift_rate = severity * 0.01 # Gradual increase base_value += drift_rate * failure_duration elif scenario['type'] == 'gradual_decrease': drift_rate = severity * 0.008 # Gradual decrease base_value -= drift_rate * failure_duration elif scenario['type'] == 'sudden_spike': if failure_duration > 5: # Spike after 5 seconds base_value += severity * 2.0 elif scenario['type'] == 'oscillation': oscillation = severity * 0.5 * np.sin(failure_duration * 2) base_value += oscillation # Add realistic noise noise = np.random.normal(0, sensor['noise_level']) final_value = max(0, base_value + noise) # Update sensor current value for next reading sensor['current_value'] = final_value sensor_data[sensor_name] = { 'value': final_value, 'normal_range': sensor['normal_range'], 'critical_threshold': sensor['critical_threshold'], 'timestamp': current_time } return sensor_data class SensorFEPMCMAgent: """FEP-MCM agent specialized for sensor data analysis.""" def __init__(self): # FEP parameters for sensor data self.latent_dim = 4 # One for each sensor type self.observation_dim = 8 # Raw values + derived features # Bayesian parameters self.prior_mean = np.zeros(self.latent_dim) self.prior_cov = np.eye(self.latent_dim) * 0.5 self.precision = 1.5 # Recognition model (sensor encoder) self.recognition_weights = np.random.randn(self.observation_dim, self.latent_dim) * 0.1 self.recognition_bias = np.zeros(self.latent_dim) # Generative model (sensor predictor) self.generative_weights = np.random.randn(self.latent_dim, self.observation_dim) * 0.1 self.generative_bias = np.zeros(self.observation_dim) # VFE and chaos tracking self.vfe_history = deque(maxlen=1000) self.prediction_errors = deque(maxlen=1000) self.anomaly_scores = deque(maxlen=1000) # Learning parameters self.learning_rate = 0.01 print(" Sensor FEP-MCM Agent initialized") def encode_sensor_observations(self, sensor_data): """Encode sensor readings into observation vector.""" features = [] # Raw sensor values (normalized) for sensor_name in ['temperature', 'vibration', 'pressure', 'current_draw']: if sensor_name in sensor_data: value = sensor_data[sensor_name]['value'] normal_max = sensor_data[sensor_name]['normal_range'][1] normalized_value = min(value / normal_max, 3.0) # Cap at 3x normal features.append(normalized_value) else: features.append(0.0) # Derived features if len(features) >= 4: # Cross-correlations and ratios temp_vib_ratio = features[0] / max(features[1], 0.01) pressure_current_ratio = features[2] / max(features[3], 0.01) total_stress = np.sqrt(sum(f**2 for f in features)) variability = np.std(features) if len(features) > 1 else 0.0 features.extend([temp_vib_ratio, pressure_current_ratio, total_stress, variability]) # Ensure we have exactly observation_dim features while len(features) < self.observation_dim: features.append(0.0) return np.array(features[:self.observation_dim]) def process_sensor_data(self, sensor_data): """Process sensor data through FEP-MCM architecture.""" # Encode observations observations = self.encode_sensor_observations(sensor_data) # Recognition model - encode to latent space latent_mean = np.dot(observations, self.recognition_weights) + self.recognition_bias latent_std = np.ones(self.latent_dim) * 0.1 # Sample from recognition distribution latent = latent_mean + latent_std * np.random.randn(self.latent_dim) # Generative model - predict observations from latent predicted_obs = np.dot(latent, self.generative_weights) + self.generative_bias # Compute VFE components reconstruction_error = np.sum((observations - predicted_obs) ** 2) / len(observations) # KL divergence between recognition and prior kl_divergence = 0.5 * np.sum( latent_mean**2 + latent_std**2 - 1 - 2*np.log(latent_std + 1e-8) ) / self.latent_dim # Total VFE vfe = self.precision * reconstruction_error + kl_divergence # Store metrics self.vfe_history.append(vfe) self.prediction_errors.append(reconstruction_error) # Anomaly scoring based on VFE anomaly_score = min(vfe / 2.0, 1.0) self.anomaly_scores.append(anomaly_score) # Update model parameters (simple gradient descent) self._update_parameters(observations, latent, predicted_obs) return { 'vfe': vfe, 'reconstruction_error': reconstruction_error, 'kl_divergence': kl_divergence, 'anomaly_score': anomaly_score, 'latent_state': latent, 'predicted_observations': predicted_obs, 'actual_observations': observations } def _update_parameters(self, observations, latent, predictions): """Update model parameters based on prediction error.""" # Update generative model prediction_error = observations - predictions self.generative_weights += self.learning_rate * np.outer(latent, prediction_error) self.generative_bias += self.learning_rate * prediction_error # Update recognition model (simplified) recognition_error = latent - np.dot(observations, self.recognition_weights) - self.recognition_bias self.recognition_weights += self.learning_rate * np.outer(observations, recognition_error) * 0.1 self.recognition_bias += self.learning_rate * recognition_error * 0.1 class SensorMCMAgent: """MCM agent for chaos detection in sensor streams.""" def __init__(self, window_size=50): self.window_size = window_size self.vfe_buffer = deque(maxlen=window_size) self.chaos_threshold = 0.8 self.anomaly_threshold = 0.6 # Chaos indicators self.chaos_detections = deque(maxlen=20) self.lyapunov_estimates = deque(maxlen=10) print(" Sensor MCM Agent initialized") def add_vfe_sample(self, vfe_value): """Add VFE sample for chaos analysis.""" self.vfe_buffer.append(vfe_value) def detect_anomalies(self): """Detect anomalies and chaos in sensor VFE stream.""" if len(self.vfe_buffer) < 10: return { 'chaos_detected': False, 'anomaly_detected': False, 'chaos_strength': 0.0, 'trend_analysis': 'insufficient_data', 'confidence': 0.0 } vfe_series = list(self.vfe_buffer) # Statistical analysis recent_mean = np.mean(vfe_series[-10:]) historical_mean = np.mean(vfe_series[:-10]) if len(vfe_series) > 10 else recent_mean vfe_variance = np.var(vfe_series) # Trend detection if len(vfe_series) >= 20: x = np.arange(len(vfe_series)) trend_slope = np.polyfit(x, vfe_series, 1)[0] else: trend_slope = 0.0 # Chaos indicators chaos_strength = 0.0 # High variance suggests chaotic behavior if vfe_variance > 0.5: chaos_strength += 0.3 # Sudden mean shift mean_shift = abs(recent_mean - historical_mean) if mean_shift > 0.5: chaos_strength += 0.4 # Positive trend (increasing VFE) if trend_slope > 0.02: chaos_strength += 0.3 # Anomaly detection anomaly_detected = recent_mean > self.anomaly_threshold chaos_detected = chaos_strength > self.chaos_threshold self.chaos_detections.append(chaos_strength) # Trend analysis if trend_slope > 0.05: trend = 'deteriorating' elif trend_slope < -0.05: trend = 'improving' elif vfe_variance > 0.8: trend = 'unstable' else: trend = 'stable' # Confidence based on data quantity and consistency confidence = min(1.0, len(self.vfe_buffer) / self.window_size) if len(self.chaos_detections) > 5: recent_chaos = list(self.chaos_detections)[-5:] chaos_std = np.std(recent_chaos) confidence *= max(0.3, 1.0 - chaos_std) return { 'chaos_detected': chaos_detected, 'anomaly_detected': anomaly_detected, 'chaos_strength': chaos_strength, 'trend_analysis': trend, 'trend_slope': trend_slope, 'mean_shift': mean_shift, 'variance': vfe_variance, 'confidence': confidence, 'recent_vfe': recent_mean } class SmartSensorMonitor: """Complete smart sensor monitoring system using FEP-MCM architecture.""" def __init__(self): print(" SMART SENSOR MONITOR - FEP-MCM APPLICATION") print("=" * 55) # Initialize components self.sensor_simulator = IndustrialSensorSimulator() self.fep_agent = SensorFEPMCMAgent() self.mcm_agent = SensorMCMAgent() # Monitoring state self.monitoring = False self.data_log = [] self.alerts = [] # Performance metrics self.metrics = { 'total_readings': 0, 'anomalies_detected': 0, 'chaos_events': 0, 'false_positives': 0, 'system_uptime': 0.0 } print(" Smart Sensor Monitor initialized") def start_monitoring(self, duration_minutes=5, reading_interval=1.0): """Start continuous sensor monitoring.""" print(f"\n Starting continuous monitoring for {duration_minutes} minutes") print(f" Reading interval: {reading_interval} seconds") self.monitoring = True start_time = time.time() end_time = start_time + (duration_minutes * 60) try: while time.time() < end_time and self.monitoring: # Read sensors sensor_data = self.sensor_simulator.read_sensors() # Process through FEP agent fep_result = self.fep_agent.process_sensor_data(sensor_data) # Analyze with MCM agent self.mcm_agent.add_vfe_sample(fep_result['vfe']) mcm_result = self.mcm_agent.detect_anomalies() # Log data log_entry = { 'timestamp': time.time(), 'sensor_data': sensor_data, 'vfe': fep_result['vfe'], 'anomaly_score': fep_result['anomaly_score'], 'chaos_detected': mcm_result['chaos_detected'], 'anomaly_detected': mcm_result['anomaly_detected'], 'trend': mcm_result['trend_analysis'] } self.data_log.append(log_entry) # Update metrics self.metrics['total_readings'] += 1 if mcm_result['anomaly_detected']: self.metrics['anomalies_detected'] += 1 if mcm_result['chaos_detected']: self.metrics['chaos_events'] += 1 # Generate alerts self._check_alerts(sensor_data, fep_result, mcm_result) # Print status if self.metrics['total_readings'] % 10 == 0: self._print_status(sensor_data, fep_result, mcm_result) time.sleep(reading_interval) except KeyboardInterrupt: print("\n Monitoring stopped by user") self.monitoring = False self.metrics['system_uptime'] = time.time() - start_time print(f"\n Monitoring completed") self._generate_report() def _check_alerts(self, sensor_data, fep_result, mcm_result): """Check for alert conditions.""" current_time = time.time() # Critical sensor thresholds for sensor_name, data in sensor_data.items(): if data['value'] > data['critical_threshold']: alert = { 'timestamp': current_time, 'type': 'CRITICAL_THRESHOLD', 'sensor': sensor_name, 'value': data['value'], 'threshold': data['critical_threshold'], 'message': f" CRITICAL: {sensor_name} = {data['value']:.2f} (threshold: {data['critical_threshold']})" } self.alerts.append(alert) print(alert['message']) # High VFE alert if fep_result['vfe'] > 2.0: alert = { 'timestamp': current_time, 'type': 'HIGH_VFE', 'vfe': fep_result['vfe'], 'message': f" HIGH VFE: {fep_result['vfe']:.3f} - System stress detected" } self.alerts.append(alert) print(alert['message']) # Chaos detection alert if mcm_result['chaos_detected']: alert = { 'timestamp': current_time, 'type': 'CHAOS_DETECTED', 'chaos_strength': mcm_result['chaos_strength'], 'message': f" CHAOS DETECTED: Strength {mcm_result['chaos_strength']:.3f} - Unpredictable behavior" } self.alerts.append(alert) print(alert['message']) # Trend alert if mcm_result['trend_analysis'] == 'deteriorating': alert = { 'timestamp': current_time, 'type': 'DETERIORATING_TREND', 'trend_slope': mcm_result['trend_slope'], 'message': f" TREND ALERT: System deteriorating (slope: {mcm_result['trend_slope']:.4f})" } self.alerts.append(alert) print(alert['message']) def _print_status(self, sensor_data, fep_result, mcm_result): """Print current monitoring status.""" print(f"\n Status Update (Reading #{self.metrics['total_readings']})") print("-" * 50) # Sensor readings for sensor_name, data in sensor_data.items(): status = "" if data['value'] > data['critical_threshold'] else "" print(f"{status} {sensor_name}: {data['value']:.2f}") # FEP-MCM analysis print(f" VFE: {fep_result['vfe']:.3f}") print(f" Anomaly Score: {fep_result['anomaly_score']:.3f}") print(f" Chaos: {'YES' if mcm_result['chaos_detected'] else 'NO'}") print(f" Trend: {mcm_result['trend_analysis']}") def _generate_report(self): """Generate comprehensive monitoring report.""" print(f"\n MONITORING REPORT") print("=" * 30) # System metrics print(f"⏱ System Uptime: {self.metrics['system_uptime']:.1f} seconds") print(f" Total Readings: {self.metrics['total_readings']}") print(f" Anomalies Detected: {self.metrics['anomalies_detected']}") print(f" Chaos Events: {self.metrics['chaos_events']}") print(f" Alert Rate: {len(self.alerts) / max(self.metrics['total_readings'], 1) * 100:.1f}%") # VFE statistics if self.fep_agent.vfe_history: vfe_values = list(self.fep_agent.vfe_history) print(f" Average VFE: {np.mean(vfe_values):.3f}") print(f" Max VFE: {np.max(vfe_values):.3f}") print(f" VFE Variance: {np.var(vfe_values):.3f}") # Alert summary if self.alerts: print(f"\n ALERT SUMMARY ({len(self.alerts)} total)") alert_types = {} for alert in self.alerts: alert_type = alert['type'] alert_types[alert_type] = alert_types.get(alert_type, 0) + 1 for alert_type, count in alert_types.items(): print(f" • {alert_type}: {count}") # Save report report = { 'timestamp': datetime.now().isoformat(), 'metrics': self.metrics, 'alerts': self.alerts, 'vfe_history': list(self.fep_agent.vfe_history), 'data_log': self.data_log[-100:] # Last 100 readings } report_path = f"sensor_monitoring_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json" with open(report_path, 'w') as f: json.dump(report, f, indent=2) print(f" Report saved to: {report_path}") return report def demonstrate_failure_detection(self): """Demonstrate failure detection capabilities.""" print(f"\n FAILURE DETECTION DEMONSTRATION") print("=" * 40) scenarios = [ ('normal_operation', 30, None), ('bearing_wear', 30, 'bearing_wear'), ('overheating', 20, 'overheating'), ('sudden_blockage', 15, 'sudden_blockage'), ('recovery', 20, None) ] for scenario_name, duration, failure_type in scenarios: print(f"\n Scenario: {scenario_name.replace('_', ' ').title()}") if failure_type: self.sensor_simulator.inject_failure(failure_type, severity=1.5) else: self.sensor_simulator.clear_failures() # Monitor for scenario duration scenario_start = time.time() readings_in_scenario = 0 while time.time() - scenario_start < duration: # Read and analyze sensor_data = self.sensor_simulator.read_sensors() fep_result = self.fep_agent.process_sensor_data(sensor_data) self.mcm_agent.add_vfe_sample(fep_result['vfe']) mcm_result = self.mcm_agent.detect_anomalies() readings_in_scenario += 1 self.metrics['total_readings'] += 1 # Check for detection if mcm_result['anomaly_detected'] or mcm_result['chaos_detected']: detection_time = time.time() - scenario_start print(f" Detected after {detection_time:.1f}s (VFE: {fep_result['vfe']:.3f})") if failure_type: print(f" Successfully identified {failure_type}") # Print periodic updates if readings_in_scenario % 10 == 0: print(f" VFE: {fep_result['vfe']:.3f}, Trend: {mcm_result['trend_analysis']}") time.sleep(1) print(f"\n Failure detection demonstration complete!") def main(): """Main function to run the smart sensor monitor.""" try: print(" SMART SENSOR MONITOR - NON-LLM FEP-MCM APPLICATION") print("=" * 60) print(" Demonstrating FEP-MCM architecture for industrial monitoring") print(" Real-time anomaly detection and predictive maintenance") print() # Create monitor monitor = SmartSensorMonitor() # Choose demonstration mode print("Select demonstration mode:") print("1. Continuous monitoring (5 minutes)") print("2. Failure detection scenarios") print("3. Both") choice = input("Enter choice (1-3): ").strip() if choice == '1' or choice == '3': print("\n Running continuous monitoring...") monitor.start_monitoring(duration_minutes=2, reading_interval=0.5) if choice == '2' or choice == '3': print("\n Running failure detection demonstration...") monitor.demonstrate_failure_detection() print("\n Smart Sensor Monitor demonstration complete!") print(" FEP-MCM architecture successfully applied to non-LLM domain!") return 0 except Exception as e: print(f" Error: {e}") import traceback traceback.print_exc() return 1 if __name__ == "__main__": sys.exit(main())